<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Canyon ðŸ’— Elioran</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <canvas id="bg"></canvas>
  <canvas id="c1"></canvas>
  <canvas id="c2"></canvas>
  <canvas id="c3"></canvas>

  <script>
    // =========================================================
    // canyon.png background (cover) + permanent dark overlay
    // âœ… Countdown REMOVED (no countdown logic, no drawing)
    // =========================================================

    // ---------- helpers ----------
    const lerp = (a, b, t) => Math.abs(b - a) > 0.0001 ? a + t * (b - a) : b;
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const easeInOut = (t) => (t < 0.5)
      ? 4 * t * t * t
      : 1 - Math.pow(-2 * t + 2, 3) / 2;

    function W() { return window.visualViewport?.width ?? window.innerWidth; }
    function H() { return window.visualViewport?.height ?? window.innerHeight; }

    function removeFrom(arr, item) {
      const idx = arr.indexOf(item);
      if (idx >= 0) arr.splice(idx, 1);
    }

    // =========================================================
    // âœ… Background canvas
    // =========================================================
    const bg = document.getElementById("bg");
    const bgCtx = bg.getContext("2d");
    const bgImg = new Image();
    bgImg.src = "canyon.png"; // put canyon.png in the same folder as this html

    function drawBackground() {
      const vw = Math.floor(W());
      const vh = Math.floor(H());
      const dpr = Math.min(window.devicePixelRatio || 1, 2);

      bg.width = Math.floor(vw * dpr);
      bg.height = Math.floor(vh * dpr);
      bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

      bgCtx.clearRect(0, 0, vw, vh);

      if (bgImg.complete && bgImg.naturalWidth) {
        const imgW = bgImg.naturalWidth;
        const imgH = bgImg.naturalHeight;

        const imgRatio = imgW / imgH;
        const screenRatio = vw / vh;

        let drawW, drawH, offsetX, offsetY;

        if (screenRatio > imgRatio) {
          drawW = vw;
          drawH = vw / imgRatio;
          offsetX = 0;
          offsetY = (vh - drawH) / 2;
        } else {
          drawH = vh;
          drawW = vh * imgRatio;
          offsetX = (vw - drawW) / 2;
          offsetY = 0;
        }

        bgCtx.drawImage(bgImg, offsetX, offsetY, drawW, drawH);
      } else {
        bgCtx.fillStyle = "#000";
        bgCtx.fillRect(0, 0, vw, vh);
      }

      // permanent dark overlay
      bgCtx.fillStyle = "rgba(0,0,0,0.35)";
      bgCtx.fillRect(0, 0, vw, vh);
    }

    bgImg.onload = drawBackground;

    // ---------- canvases ----------
    const c1 = document.getElementById("c1");
    const c2 = document.getElementById("c2");
    const c3 = document.getElementById("c3");
    const ctx1 = c1.getContext("2d");
    const ctx2 = c2.getContext("2d");
    const ctx3 = c3.getContext("2d");

    // ---------- text ----------
    const TEXT = "Canyon ðŸ’— Elioran";

    // ---------- knobs ----------
    const MAX_DPR = 2; // âœ… only declared ONCE now
    const FONT_WEIGHT = 600;
    const FONT_FAMILY = "system-ui, -apple-system, Segoe UI, Arial, sans-serif";

    const TEXT_FILL = "#fff1f6";
    const TEXT_GLOW = "#ff4f8b";
    const TEXT_GLOW_BLUR = 52;
    const TEXT_ALPHA = 1.0;

    const HEART_GLOW_BLUR = 28;
    const HEART_ALPHA = 1.0;

    const BARRAGE_SCALE = 0.70;

    // sampling density + heart resolution
    let fidelity = 4;
    let heartPointCount = 260;

    // formation engine
    const rockets = [];
    const shards = [];
    let targets = [];
    let formedPoints = [];
    let totalTargets = 1;

    // heart
    let heartPolyline = [];
    const fireflies = [];

    // layout
    let fontSize = 140;
    let textWidth = 0;
    let textHeight = 0;
    let textBox = { left: 0, top: 0, right: 0, bottom: 0 };
    let textFormed = false;
    let heartStarted = false;

    // ---------- classes ----------
    class Shard {
      constructor(x, y, hue, v0) {
        this.x = x;
        this.y = y;
        this.hue = hue;
        this.lightness = 58;
        this.size = 13 + Math.random() * 7;

        if (v0) {
          this.xSpeed = v0.vx;
          this.ySpeed = v0.vy;
        } else {
          const angle = Math.random() * 2 * Math.PI;
          const blastSpeed = 1 + Math.random() * 6;
          this.xSpeed = Math.cos(angle) * blastSpeed;
          this.ySpeed = Math.sin(angle) * blastSpeed;
        }

        this.target = getTarget();
        this.ttl = 110;
        this.timer = 0;

        this.trail = [];
        this.trailMax = (W() < 500) ? 7 : 10;
      }

      draw(now) {
        if (this.trail.length > 1) {
          ctx2.save();
          for (let i = 0; i < this.trail.length; i++) {
            const p = this.trail[i];
            const t = i / this.trail.length;
            ctx2.globalAlpha = 0.22 * t;
            ctx2.fillStyle = `hsl(${this.hue}, 100%, ${Math.min(95, this.lightness + 25)}%)`;
            ctx2.beginPath();
            ctx2.arc(p.x, p.y, 1.1 + 2.4 * t, 0, Math.PI * 2);
            ctx2.fill();
          }
          ctx2.restore();
        }

        ctx2.fillStyle = `hsl(${this.hue}, 100%, ${this.lightness}%)`;
        ctx2.beginPath();
        ctx2.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx2.fill();
      }

      update() {
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > this.trailMax) this.trail.shift();

        if (this.target) {
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const dist = Math.hypot(dx, dy);

          const a = Math.atan2(dy, dx);
          const tx = Math.cos(a) * 5;
          const ty = Math.sin(a) * 5;

          this.size = lerp(this.size, 1.2, 0.05);

          if (dist < 5) {
            this.lightness = lerp(this.lightness, 100, 0.025);
            this.xSpeed = this.ySpeed = 0;
            this.x = lerp(this.x, this.target.x + fidelity / 2, 0.08);
            this.y = lerp(this.y, this.target.y + fidelity / 2, 0.08);
            this.timer += 1;
          } else if (dist < 12) {
            this.lightness = lerp(this.lightness, 100, 0.02);
            this.xSpeed = lerp(this.xSpeed, tx, 0.14);
            this.ySpeed = lerp(this.ySpeed, ty, 0.14);
            this.timer += 1;
          } else {
            this.xSpeed = lerp(this.xSpeed, tx, 0.035);
            this.ySpeed = lerp(this.ySpeed, ty, 0.035);
          }
        } else {
          this.ySpeed += 0.05;
          this.size = lerp(this.size, 1, 0.05);
          if (this.y > H() + 60) removeFrom(shards, this);
        }

        this.x += this.xSpeed;
        this.y += this.ySpeed;
      }
    }

    class Rocket {
      constructor() {
        const quarterW = W() / 4;
        this.x = quarterW + Math.random() * (W() - quarterW);
        this.y = H() - 15;

        this.angle = Math.random() * Math.PI / 4 - Math.PI / 6;
        this.blastSpeed = 6 + Math.random() * 7;

        this.xSpeed = Math.sin(this.angle) * this.blastSpeed;
        this.ySpeed = -Math.cos(this.angle) * this.blastSpeed;

        this.hue = Math.floor(Math.random() * 360);
        this.mobile = W() < 500;
      }

      draw() {
        ctx2.save();
        ctx2.translate(this.x, this.y);
        ctx2.rotate(Math.atan2(this.ySpeed, this.xSpeed) + Math.PI / 2);
        ctx2.fillStyle = `hsl(${this.hue}, 100%, 60%)`;
        ctx2.fillRect(0, 0, 5, 15);
        ctx2.restore();
      }

      update() {
        this.x += this.xSpeed;
        this.y += this.ySpeed;
        this.ySpeed += 0.1;
      }

      explode() {
        const baseCount = this.mobile ? 52 : 85;
        const count = Math.max(18, Math.floor(baseCount * BARRAGE_SCALE));
        const heartRatio = this.mobile ? 0.30 : 0.42;

        for (let i = 0; i < count; i++) {
          let v0 = null;

          if (Math.random() < heartRatio) {
            const t = Math.random() * Math.PI * 2;
            const hx = 16 * Math.pow(Math.sin(t), 3);
            const hy = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            const len = Math.hypot(hx, hy) || 1;
            const nx = hx / len;
            const ny = -hy / len;
            const speed = 2.2 + Math.random() * 6.6;
            v0 = { vx: nx * speed, vy: ny * speed };
          }

          shards.push(new Shard(this.x, this.y, this.hue, v0));
        }
      }
    }

    class Firefly {
      constructor(idx) {
        this.idx = idx;
        this.pathN = heartPolyline.length;

        const angle = Math.random() * Math.PI * 2;
        const r = Math.max(W(), H()) * (0.45 + Math.random() * 0.25);
        this.x = W() / 2 + Math.cos(angle) * r;
        this.y = H() / 2 + Math.sin(angle) * r;

        this.vx = 0;
        this.vy = 0;

        this.phase = Math.random() * Math.PI * 2;
        this.twSpeed = 0.004 + Math.random() * 0.008;

        this.hue = 44 + Math.random() * 18;
        this.size = 1.3 + Math.random() * 2.0;

        this.settled = false;

        this.flowing = Math.random() < 0.55;
        this.flowSpeed = (Math.random() < 0.5 ? 1 : -1) * (0.20 + Math.random() * 0.55);
        this.flowJitter = 0.6 + Math.random() * 1.3;
      }

      anchor() {
        return heartPolyline[Math.floor(this.idx) % this.pathN];
      }

      update(now) {
        if (this.settled && this.flowing) {
          const breathe = 0.7 + 0.3 * Math.sin(now * 0.0015 + this.phase);
          const step = this.flowSpeed * breathe;
          this.idx = (this.idx + step + this.pathN) % this.pathN;
        }

        const a = this.anchor();
        const dx = a.x - this.x;
        const dy = a.y - this.y;
        const dist = Math.hypot(dx, dy) || 1;

        const k = this.settled ? 0.010 : 0.024;
        let ax = (dx / dist) * k * Math.min(dist, 90);
        let ay = (dy / dist) * k * Math.min(dist, 90);

        ax += Math.sin(now * 0.002 + this.phase) * 0.22;
        ay += Math.cos(now * 0.0022 + this.phase * 1.3) * 0.22;

        this.vx = (this.vx + ax) * 0.92;
        this.vy = (this.vy + ay) * 0.92;

        this.x += this.vx;
        this.y += this.vy;

        if (!this.settled && dist < 12) this.settled = true;

        if (this.settled) {
          const hover = this.flowJitter;
          this.x = lerp(this.x, a.x + Math.sin(now * 0.006 + this.phase) * hover, 0.07);
          this.y = lerp(this.y, a.y + Math.cos(now * 0.006 + this.phase) * hover, 0.07);
        }
      }

      draw(now) {
        const tw = 0.75 + 0.25 * Math.sin(now * this.twSpeed + this.phase);

        ctx3.save();
        ctx3.globalAlpha = HEART_ALPHA * tw;
        ctx3.fillStyle = `hsl(${this.hue}, 100%, 82%)`;
        ctx3.shadowColor = `hsla(${this.hue}, 100%, 70%, 1)`;
        ctx3.shadowBlur = HEART_GLOW_BLUR * (0.9 + 0.35 * tw);

        const s = this.size * (0.95 + 0.25 * tw);
        ctx3.beginPath();
        ctx3.arc(this.x, this.y, s, 0, Math.PI * 2);
        ctx3.fill();
        ctx3.restore();
      }
    }

    // ---------- text targets ----------
    function rebuildTextTargets() {
      targets = [];
      formedPoints = [];
      totalTargets = 1;
      textFormed = false;
      heartStarted = false;
      fireflies.length = 0;

      fidelity = (W() < 500) ? 6 : 4;
      heartPointCount = (W() < 500) ? 190 : 280;

      let fs = Math.min(180, Math.floor(W() * 0.20));
      ctx1.font = `${FONT_WEIGHT} ${fs}px ${FONT_FAMILY}`;
      let tw = ctx1.measureText(TEXT).width;

      while (tw > W() * 0.92 && fs > 18) {
        fs -= 2;
        ctx1.font = `${FONT_WEIGHT} ${fs}px ${FONT_FAMILY}`;
        tw = ctx1.measureText(TEXT).width;
      }

      fontSize = fs;
      textWidth = tw;
      textHeight = Math.ceil(fontSize * 1.25);

      c1.width = Math.ceil(textWidth);
      c1.height = textHeight;

      ctx1.clearRect(0, 0, c1.width, c1.height);
      ctx1.fillStyle = "#000";
      ctx1.font = `${FONT_WEIGHT} ${fontSize}px ${FONT_FAMILY}`;
      ctx1.textAlign = "center";
      ctx1.textBaseline = "alphabetic";
      ctx1.fillText(TEXT, c1.width / 2, fontSize);

      const img = ctx1.getImageData(0, 0, c1.width, c1.height);
      for (let i = 0; i < img.data.length; i += 4) {
        const alpha = img.data[i + 3];
        if (!alpha) continue;

        const x = (i / 4) % img.width;
        const y = Math.floor((i / 4) / img.width);

        if (x % fidelity === 0 && y % fidelity === 0) targets.push({ x, y });
      }

      totalTargets = Math.max(1, targets.length);

      const left = W() / 2 - textWidth / 2;
      const top  = H() / 2 - c1.height / 2;
      textBox = { left, top, right: left + textWidth, bottom: top + c1.height };

      heartPolyline = buildHeartPolyline(textBox, heartPointCount);
    }

    function getTarget() {
      if (targets.length === 0) return null;

      const idx = Math.floor(Math.random() * targets.length);
      let { x, y } = targets[idx];
      targets.splice(idx, 1);

      x += W() / 2 - textWidth / 2;
      y += H() / 2 - c1.height / 2;

      return { x, y };
    }

    // ---------- heart polyline ----------
    function heartCurve(t) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
      return { x, y: -y };
    }

    function buildHeartPolyline(box, count) {
      const cx = (box.left + box.right) / 2;
      const cy = (box.top + box.bottom) / 2;

      const desiredW = (box.right - box.left) * 1.65;
      const desiredH = (box.right - box.left) * 1.32;

      const samples = Math.max(900, count * 4);
      const pts = [];
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

      for (let i = 0; i < samples; i++) {
        const t = (i / samples) * Math.PI * 2;
        const p = heartCurve(t);
        pts.push(p);
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
      }

      const heartW = maxX - minX;
      const heartH = maxY - minY;

      const s = Math.min(desiredW / heartW, desiredH / heartH);

      const poly = [];
      const step = Math.floor(samples / count);

      for (let i = 0; i < samples; i += step) {
        const p = pts[i % pts.length];
        poly.push({
          x: cx + (p.x - (minX + heartW / 2)) * s,
          y: cy + (p.y - (minY + heartH / 2)) * s
        });
        if (poly.length >= count) break;
      }

      return poly;
    }

    // ---------- DPR resize ----------
    function resize() {
      drawBackground();

      const vw = Math.floor(W());
      const vh = Math.floor(H());
      const dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);

      c2.width = Math.floor(vw * dpr);
      c2.height = Math.floor(vh * dpr);
      c3.width = Math.floor(vw * dpr);
      c3.height = Math.floor(vh * dpr);

      ctx2.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx3.setTransform(dpr, 0, 0, dpr, 0, 0);

      ctx2.clearRect(0, 0, vw, vh);
      ctx3.clearRect(0, 0, vw, vh);

      rockets.length = 0;
      shards.length = 0;
      rebuildTextTargets();
    }

    resize();
    window.addEventListener("resize", resize);
    window.visualViewport?.addEventListener("resize", resize);
    window.addEventListener("orientationchange", resize);

    // ---------- render glow layer ----------
    function renderGlow(now) {
      ctx3.clearRect(0, 0, W(), H());

      // Text: particles
      ctx3.save();
      ctx3.fillStyle = TEXT_FILL;
      ctx3.shadowColor = TEXT_GLOW;
      ctx3.shadowBlur = TEXT_GLOW_BLUR;

      for (let i = 0; i < formedPoints.length; i++) {
        const p = formedPoints[i];
        const tw = 0.92 + 0.08 * Math.sin(now * p.twSpeed + p.phase);
        ctx3.globalAlpha = TEXT_ALPHA * tw;
        const s = p.size * (0.96 + 0.10 * tw);
        ctx3.fillRect(p.x, p.y, s, s);
      }
      ctx3.restore();

      // Heart fireflies
      for (let i = 0; i < fireflies.length; i++) {
        fireflies[i].draw(now);
      }
    }

    // ---------- main loop ----------
    let counter = 0;

    (function loop(now = performance.now()) {
      ctx2.fillStyle = "rgba(0, 0, 0, 0.12)";
      ctx2.fillRect(0, 0, W(), H());

      counter += 1;
      const mobile = W() < 500;

      const baseSpawnEvery = mobile ? 22 : 16;
      const spawnEvery = Math.max(6, Math.floor(baseSpawnEvery / BARRAGE_SCALE));

      if (!textFormed && counter % spawnEvery === 0) rockets.push(new Rocket());

      for (let i = rockets.length - 1; i >= 0; i--) {
        const r = rockets[i];
        r.draw();
        r.update();
        if (r.ySpeed > 0) {
          r.explode();
          rockets.splice(i, 1);
        }
      }

      for (let i = shards.length - 1; i >= 0; i--) {
        const s = shards[i];
        s.draw(now);
        s.update();

        if (s.target && (s.timer >= s.ttl || s.lightness >= 99)) {
          formedPoints.push({
            x: s.target.x,
            y: s.target.y,
            phase: Math.random() * Math.PI * 2,
            twSpeed: 0.004 + Math.random() * 0.006,
            size: (mobile ? 1.25 : 1.05) + (Math.random() - 0.5) * 0.45
          });
          shards.splice(i, 1);
        }
      }

      // detect completion
      if (!textFormed) {
        const progress = 1 - (targets.length / totalTargets);
        if (progress > 0.995 && shards.length < (mobile ? 16 : 24)) {
          textFormed = true;
        }
      }

      if (textFormed && !heartStarted) heartStarted = true;

      if (heartStarted && fireflies.length < heartPolyline.length) {
        const addPerFrame = mobile ? 3 : 4;
        for (let k = 0; k < addPerFrame; k++) {
          const idx = fireflies.length;
          if (idx >= heartPolyline.length) break;
          fireflies.push(new Firefly(idx));
        }
      }

      for (let i = 0; i < fireflies.length; i++) {
        fireflies[i].update(now);
      }

      renderGlow(now);
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
